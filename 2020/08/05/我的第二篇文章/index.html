<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>我的第二篇文章 | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="第一题、给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。给定 nums &#x3D; [2, 7, 11, 15], target &#x3D; 9 因为 nums[0] + nums[1] &#x3D; 2 + 7 &#x3D; 9所以返回 [0, 1] 解法一：暴力解法：双循环遍历，时间">
<meta property="og:type" content="article">
<meta property="og:title" content="我的第二篇文章">
<meta property="og:url" content="http://yoursite.com/2020/08/05/%E6%88%91%E7%9A%84%E7%AC%AC%E4%BA%8C%E7%AF%87%E6%96%87%E7%AB%A0/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="第一题、给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。给定 nums &#x3D; [2, 7, 11, 15], target &#x3D; 9 因为 nums[0] + nums[1] &#x3D; 2 + 7 &#x3D; 9所以返回 [0, 1] 解法一：暴力解法：双循环遍历，时间">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2020-08-05T09:10:05.000Z">
<meta property="article:modified_time" content="2020-08-05T09:10:28.225Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 4.2.1"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-我的第二篇文章" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/08/05/%E6%88%91%E7%9A%84%E7%AC%AC%E4%BA%8C%E7%AF%87%E6%96%87%E7%AB%A0/" class="article-date">
  <time datetime="2020-08-05T09:10:05.000Z" itemprop="datePublished">2020-08-05</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      我的第二篇文章
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>第一题、给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。<br>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。<br>给定 nums = [2, 7, 11, 15], target = 9</p>
<p>因为 nums[0] + nums[1] = 2 + 7 = 9<br>所以返回 [0, 1]</p>
<p>解法一：暴力解法：双循环遍历，时间复杂度为O(n)<br>解法二：查看target-nums[i]的结果是否在HashMap中，在的话就返回对应map的下标和当前下标（i）<br>不在hashMap中则map.put(nums[i],i);<br>时间复杂度为O(1)</p>
<p>第二题、整数反转<br>给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。</p>
<p>示例 1:<br>输入: 123<br>输出: 321</p>
<p>示例 2:<br>输入: -123<br>输出: -321</p>
<p>示例 3:<br>输入: 120<br>输出: 21<br>解法一：字符串反转：用到了StringBuffer(String s).resverse.toString<br>注意的点是如果为负数，需要提前判断，s = s.subString(1)开始<br>解法二：这里复习下基本数据类型的取值范围<br>1、<br>基本类型：short 二进制位数：16<br>包装类：java.lang.Short<br>最小值：Short.MIN_VALUE=-32768 （-2的15此方）<br>最大值：Short.MAX_VALUE=32767 （2的15次方-1）<br>2、<br>基本类型：int 二进制位数：32<br>包装类：java.lang.Integer<br>最小值：Integer.MIN_VALUE= -2147483648 （-2的31次方）<br>最大值：Integer.MAX_VALUE= 2147483647  （2的31次方-1）<br>3、<br>基本类型：long 二进制位数：64<br>包装类：java.lang.Long<br>最小值：Long.MIN_VALUE=-9223372036854775808 （-2的63次方）<br>最大值：Long.MAX_VALUE=9223372036854775807 （2的63次方-1）<br>4、<br>基本类型：float 二进制位数：32<br>包装类：java.lang.Float<br>最小值：Float.MIN_VALUE=1.4E-45 （2的-149次方）<br>最大值：Float.MAX_VALUE=3.4028235E38 （2的128次方-1）<br>5、<br>基本类型：double 二进制位数：64<br>包装类：java.lang.Double<br>最小值：Double.MIN_VALUE=4.9E-324 （2的-1074次方）<br>最大值：Double.MAX_VALUE=1.7976931348623157E308 （2的1024次方-1）<br>给数字做反转的方法<br>res=0;<br>while(a!=0)<br>a =num%10<br>num/10<br>res=res*10+a;<br>需要判断res的范围（1）可以先指定res为long类型，这时只需要使得res&lt;=Integer.MAX_VALUE以及res&lt;=Integer.MIN_VALUE即可</p>
<p>第三题 回文数<br>例如：反转是自己的数字就为回文数 121 1221<br>解法一：字符串反转<br>解法二：while(a!=0)<br>a =num%10<br>num/10<br>res=res*10+a;看看是否和判断的数字相等？<br>注意！！！！：输入的数字需要再int一个数字进行替代，不然最后判断的时候不成立。</p>
<p>第四题 罗马数字转整数<br>解法：需要注意的点是，IV是4 IX是9，他们比直接加或者减少了2，需要在结果上-2.</p>
<p>第五题：最长公共子串<br>写一个函数来查找字符串数组中的最长公共前缀。</p>
<p>如果不存在公共前缀，返回空字符串 “”。</p>
<p>示例 1:</p>
<p>输入: [“flower”,”flow”,”flight”]<br>输出: “fl”<br>示例 2:</p>
<p>输入: [“dog”,”racecar”,”car”]<br>输出: “”<br>解释: 输入不存在公共前缀。</p>
<p>解法：先找出[“flower”,”flow”,”flight”]中的最小的字符串以及其size，是flow(minString)<br>然后遍历，如果剩下的字符串的startsWith(minString),那么就返回minString<br>否则：minString就应该减少一位，如 flow变成flo ，使用subString（0，index），这里的话就是index-1.<br>在index&gt;0的情况下进行循环操作，在while结束时startWith（minString）还是false的话则不存在公共前缀。</p>
<p>第六题：判断子序列<br>给定字符串 s 和 t ，判断 s 是否为 t 的子序列。</p>
<p>你可以认为 s 和 t 中仅包含英文小写字母。字符串 t 可能会很长（长度 ~= 500,000），而 s 是个短字符串（长度 &lt;=100）。</p>
<p>字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。（例如，”ace”是”abcde”的一个子序列，而”aec”不是）。</p>
<p>示例 1:<br>s = “abc”, t = “ahbgdc”</p>
<p>返回 true.</p>
<p>示例 2:<br>s = “axc”, t = “ahbgdc”</p>
<p>返回 false</p>
<p>解法：首先while循环的条件是j的长度不能长于j，<br>然后从0位置开始循环遍历s字符串和t字符串，如果s的子字符中有和t的相等的，那么就i就加1遍历下一个<br>否则i不加，j往下加，继续找。</p>
<p>循环结束后，如果是正确的话，i的大小应该等于s的长度。否则为false。</p>
<p>第七题：有效的括号（String s）<br>示例 1:</p>
<p>输入: “()”<br>输出: true<br>示例 2:</p>
<p>输入: “()[]{}”<br>输出: true<br>示例 3:</p>
<p>输入: “(]”<br>输出: false<br>示例 4:</p>
<p>输入: “([)]”<br>输出: false<br>示例 5:</p>
<p>输入: “{[]}”<br>输出: true<br>注意这个实例5.<br>这道题用到了辅助栈。注意是辅助栈，并不是真正的栈。<br>首先将正确的对应存入map中，如put{‘(‘,’)’}<br>接下来是做一些判断，<br>1、如果s的长度为奇数，那么肯定为false<br>2、如果s中存储的第一个不是map中的元素的话，肯定为false<br>开始算法的思路：<br>开始循环：<br>如果为 map的key （如’（’） 那么就将他存入栈中，如果不是key而是value如（’]’）那么就将当前栈顶的元素出栈并且取出其对应的value（栈中只保存了key）<br>看是否对应当前的字符，如果不对应那么返回fasle<br>循环结束后，如果为true 那么栈应该为空，全都出栈了，不为空则为false（想一下可能是”（（”这种情况）</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/08/05/%E6%88%91%E7%9A%84%E7%AC%AC%E4%BA%8C%E7%AF%87%E6%96%87%E7%AB%A0/" data-id="ckdh5ox8v0009tkr1c2ucaod6" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="/2020/08/05/%E4%B8%80%E5%91%A8%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">一周算法总结</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/08/">August 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/07/">July 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/08/05/%E6%88%91%E7%9A%84%E7%AC%AC%E4%BA%8C%E7%AF%87%E6%96%87%E7%AB%A0/">我的第二篇文章</a>
          </li>
        
          <li>
            <a href="/2020/08/05/%E4%B8%80%E5%91%A8%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/">一周算法总结</a>
          </li>
        
          <li>
            <a href="/2020/08/05/Hadoop%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">Hadoop学习笔记</a>
          </li>
        
          <li>
            <a href="/2020/08/05/Flink%20Checkpoint%E6%9C%80%E6%96%B0%E7%90%86%E8%A7%A3/">Flink Checkpoint最新理解</a>
          </li>
        
          <li>
            <a href="/2020/07/18/Flink-%E6%BA%90%E7%A0%81%EF%BC%9ACheckpoint-%E5%85%83%E6%95%B0%E6%8D%AE%E8%AF%A6%E8%A7%A3/">Flink 源码：Checkpoint 元数据详解</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>